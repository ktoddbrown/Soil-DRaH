---
title: "Carbon in Peat on EArth through Time"
author: "Vaasuki Marupaka"
date: "Summer 2024"
output: html_document
---

The purpose of this document is to summarize the portions of the Carbon in Peat on EArth through Time (C-PEAT) Database that are relevant to data collections in the SoilDRaH project and walk through the data ingestion.
Here you will find links to documentation from the data provider, links to where you can access the data, a description of how the data was processed, and visuals for the collection relevant variables.

# What is C-PEAT

The version of the Carbon in Peat on EArth through Time (C-PEAT)Database described here is the public facing version of the PANGAEA repository (https://www.pangaea.de).

The annotations table draws heavily from the parameters list of the original data and also from the point of contact for C-PEAT collection of datasets (Dr. Julie Loisel). 

# Data processing

```{r setup, echo=TRUE, warning=FALSE, message=FALSE}

library(readr) # read in the csv tables
library(tibble) # use tibbles instead of a data frame
library(plyr) # transform a list into a data frame for the bind
library(dplyr) # work with data tables filters/joins/reframes
library(tidyr) # work with data table pivots
library(ggplot2) # make plots
library(stringr) # extract text from descriptions
library(knitr) # make prettier tables
library(kableExtra) #make tables scrollable
library(pangaear)

source("../R/readCPEAT.R", local = knitr::knit_global())

#locate the data locally
dataDir <- './temp'
dataAnnotations <- './data/CPEAT_annotations.csv'
```

```{r, echo=FALSE}
#Change this file to run locally for you
#dataDir  <- '~/Dropbox (UFL)/Research/Datasets/'
```

To read in the data base use the `readCPEAT` function.

```{r, warning=FALSE}
CPEAT.ls <- readCPEAT(dataDir, 
                  annotationFilename = dataAnnotations, 
                  verbose = FALSE, #when first running, switch this to true 
                  format = 'long')


CPEAT.ls$long %>%
  slice_head(n=100) %>%
  knitr::kable() %>%
  kable_paper() %>%
  scroll_box(width = "100%", height = "300px")
```

```{r, eval=FALSE}
# TODO: Check data integrity of the long format
# Are all the rows identifiable? Can you match columns to their orginal rows and reconstruct the orginal tables?
```


There are two tables currently annotated in the C-PEAT data collection.
This represents the data directly relevant for layer-level soil carbon measurements including bulk density, organic carbon fraction, coarse fraction, depth of sample, sampling time, and sample location.
Below are the descriptions of data columns organized by table.

Please note that there is quite a bit more data in the C-PEAT and we welcome interested parties extending these annotations.

## STUDY TABLE 

```{r}
knitr::kable(CPEAT.ls$annotations %>%
               filter(of_type == 'description',
                      table_id == 'study') %>%
               select(column_id, of_variable, description = with_entry)) %>%
  kable_paper() %>%
  scroll_box(width = "100%", height = "300px")
```

## CORE TABLE

```{r}
knitr::kable(CPEAT.ls$annotations %>%
               filter(of_type %in% c('description', 'unit'),
                      table_id == 'core') %>%
               select(column_id, of_variable, description = with_entry)) %>%
  kable_paper() %>%
  scroll_box(width = "100%", height = "300px")

# test <- CPEAT.ls$annotations %>%
#                filter(of_type %in% c('description', 'unit'),
#                       table_id == 'core') %>%
#               select(column_id, of_variable, description = with_entry)
```

# Subseting for soil carbon

There is a lot of data here but not all of it is of interest for all purposes.
In this example we are interested in layer-level soil carbon related measurements, there geolocation.
Note that we are NOT checking any of the quality control flags here which you would want to do if using this for research purposes.

```{r}
# this function reads much better!
CPEAT_soc_cores <- CPEAT.ls$core %>% 
  select(doi, `Depth sed [m]`, `Depth top [m]`, `Depth bot [m]`, 
         `Depth sed [m] (Sample midpoint depth)`, 
         `Depth sed [m] (Sample midpoint depth (rounded))`, 
         `Depth sed [m] (Sample midpoint depth of OxCa...)`, 
         `Depth sed [m] (Sample midpoint depth of Baco...)`,
         `Depth sed [m] (LOI sample depth)`,
         `Samp thick [cm]`, `DBD [g/cm**3]`, `OM [%]`, `OM dens [g/cm**3]`, `Corg dens [g/cm**3]`,
         `TC [%]`, `TOC [%]`, `C [%]`, `LOI [%]`, `LOI [%] (weight-%)`, `TIC [%]`) %>% 
    dplyr::full_join(CPEAT.ls$study,
                     by = dplyr::join_by(doi)) %>% 
    dplyr::group_by(doi) %>%
    dplyr::mutate(row_number = row_number()) %>% 
    dplyr::ungroup() %>%
    tidyr::pivot_longer(cols = -row_number, 
                        names_to = 'column_id', 
                        values_to = 'with_entry', 
                        values_drop_na = TRUE) %>% 
    left_join(CPEAT.ls$annotations, 
              by = join_by(column_id),
              suffix = c('.data', ''),
              relationship = "many-to-many") %>% 
    mutate(with_entry = dplyr::if_else((with_entry == "--") | is.na(with_entry),
                                  with_entry.data, with_entry)) %>%
    select(-with_entry.data) %>% 
    select(table_id, column_id, of_variable, is_type = of_type, with_entry, row_number) # 5,546,485 obs, 6 total columns


```

## Casting values

Finally make sure that the numbers are actually numbers.

```{r}

soil_carbon.df <- CPEAT.ls$core %>% 
  select(doi, 
         contains('Depth sed'),
         #`Depth sed [m]`, 
         # `Depth sed [m] (Sample midpoint depth)`, 
         # `Depth sed [m] (Sample midpoint depth (rounded))`, 
         # `Depth sed [m] (Sample midpoint depth of OxCa...)`, 
         # `Depth sed [m] (Sample midpoint depth of Baco...)`,
         # `Depth sed [m] (LOI sample depth)`,
         `Depth top [m]`, `Depth bot [m]`, 
         `Samp thick [cm]`, `DBD [g/cm**3]`, `OM [%]`, `OM dens [g/cm**3]`, `Corg dens [g/cm**3]`,
         `TC [%]`, `TOC [%]`, `C [%]`, `LOI [%]`, `LOI [%] (weight-%)`, `TIC [%]`) %>% 
 dplyr::mutate(across(-doi, as.numeric))
  
soil_carbon.df %>%
  slice_head(n=100) %>%
  knitr::kable() %>%
  kable_paper() %>%
  scroll_box(width = "100%", height = "300px")

```

## Make small tables

Often this data is presented in three tables: a site level table with lat/lon and year, a layer level table with the depth and physiochemical information, and a meta table with information on the units and descriptions.
We given an example below of how this might be organized.

```{r}
site.df <- CPEAT.ls$study %>%
  select(doi, core_name, LATITUDE, LONGITUDE, LOCATION, ELEVATION, ELEVATION.START, ELEVATION.END) %>%
  unique()

layer.df <- soil_carbon.df %>%
  left_join(CPEAT.ls$study %>% 
              select(doi, core_name, citation),
            by = join_by(doi))

meta.df <- CPEAT.ls$annotations %>%
  #identify the variables that we are interested in
  filter(of_variable %in% c('data_doi',
             'site', 'longtitude', 'latitude', 'location',
             'layer_center', 'layer_thickness', 'layer_midpoint', 'layer_depth_top', 'layer_depth_bottom',
             'bulk_density',
             'organic_matter_fraction', 'organic_matter_density', 'organic_carbon_density',
             'total_carbon', 'total_organic_carbon', 'loss_on _ignition', 'percent_carbon',
             'depth_loi', 'LOI', 'Total_inorganic_carbon', 'depth'),
         table_id %in% c('study', 'core'))

```

# Construct annotations

The annotations were partially constructed from the parameters table and other metadata provided with these data sets.
What follows is documentation code (not to be run) that shows how this was done.

```{r eval=FALSE}

#The code below is for documentation and developement purposes only and should not be executed when the code is generated.

stop('The code below here should not execute.')


# load in the original datasets from PANGAEA
CPEAT.original <- readCPEAT(dataDir, 
                  annotationFilename = dataAnnotations, 
                  verbose = TRUE,
                  format = 'original')


```

## Process data package

The CPEAT cores are complex data structures, each core contains a list with several primary and metadata elements.
In the following section we are going to disentangle the the structures and reallign truncated column names.

```{r}
str(CPEAT.original[1])
```

```{r}

#############################
###Shoestring all the data

  long.df <- plyr::ldply(CPEAT.original, .id = 'doi',
                             .fun = function(xx, verbose = FALSE) {
    
    if(verbose) print(paste('Processing - ', xx$doi))
                               
    ###################################
    #### Process layer data
                               
    if(length(names(xx$data)) > length(unique(names(xx$data)))){
      #warning(names(xx$data))
      warning(paste(xx$doi, "- Duplicate column names detected"))
      #TODO make this more elegant
      #right now pivoting column names has to be unique so adding a counter to the end
      names(xx$data) <- paste(names(xx$data), 1:length(names(xx$data)))
    }
                               
    colume_number <- tibble(column_name = names(xx$data),
                            column_number = 1:length(names(xx$data)))
    
    layerData <- xx$data %>%
      mutate(across(.cols = everything(), as.character)) %>%
      mutate(row_number = 1:n()) %>%
      pivot_longer(cols = -row_number, names_to = 'column_name',
                   values_to = 'with_entry',
                   values_drop_na = TRUE) %>%
      left_join(colume_number, by = join_by(column_name)) %>%
      mutate(table_name = 'data')
    
    #####################################
    ### Process primary study information
    ### This information is stored in the first level list
    
    #list out all the possible names for the study info, be sure to update
    #...this list manually if the warning is thrown.
    primaryNames <- intersect(names(xx), c('parent_doi', 'doi', 'citation', 
                                           'url', 'path'))
    
    #There shouldn't be any names that we don't include above.
    if(any( ! (names(xx) %in% c(primaryNames, 'metadata', 'data')))){
      warning(paste('possible missing informatin at primary level for', xx$doi,
                    setdiff(names(xx), c(primaryNames, 'metadata', 'data'))))
    }
    
    ##############
    ###Meta data
    ###This information is stored under a list named 'metadata'
    
    #deal with the information in the metadata, again we name each possible
    #...list item here and if there are new names this needs to be updated.
    metaNames <- intersect(names(xx$metadata), c("citation", "related_to", "further_details",
                                                 "projects" , "coverage",
                                                 "abstract", "keywords",
                                                 "status",
                                                 "license", "size", "comment"))
    
    if(any( ! (names(xx$metadata) %in% c(metaNames, 'events', 'parameters')))){
      warning(paste('possible missing informatin at metadata level for', xx$doi))
    }
    
    #############
    ###Events
    ###This information is under the list 'metadata$events'
    
    #Pull in the study information from the 'events' item in the list
    #...again there should be no items that are not matching the manual array here
    eventsNames <- intersect(names(xx$metadata$events), 
                             c("LATITUDE", "LONGITUDE",
                               "ELEVATION", "ELEVATION START", "ELEVATION END",
                               "Penetration", "Recovery",
                               "LOCATION", "METHOD/DEVICE", 
                               "COMMENT"))
    
    #Take out the first item of the list which is actually the core name itself.
    if(any( ! (names(xx$metadata$events)[-1] %in%  
               c("LATITUDE", "LONGITUDE", "ELEVATION",
                 "ELEVATION START", "ELEVATION END", 
                 "Penetration","Recovery",
                 "LOCATION", "METHOD/DEVICE", "COMMENT")))){
      warning(paste('possible missing informatin at metadata-events level for', xx$doi))
    }
    
    
    #The core name is a special case where the information is in the name and not
    #...in the list values. Deal with that and append the events information.
    studyData <- as.data.frame(c(xx[primaryNames], 
                                 xx$metadata[metaNames],
                                 list(core_name = names(xx$metadata$events)[1]),
                                 xx$metadata$events[eventsNames])) %>%
      pivot_longer(cols = everything(), 
                   names_to = 'column_name',
                   values_to = 'with_entry')
    
    
    ####### 
    ###Process parameter information
    
    if(xx$doi == "10.1594/PANGAEA.934274" &
       length(xx$metadata$parameters) > nrow(colume_number)){
      #A comment on the data age material got split between two column entries here
      #...combine them into the same entry
      xx$metadata$parameters[[5]] <- c(xx$metadata$parameters[[5]],
                                           xx$metadata$parameters[[6]])
      xx$metadata$parameters[6] <- NULL
    }
    
    colume_number$description <- unlist(lapply(xx$metadata$parameters, 
                                               function(yy){
      return(paste(as.character(yy), collapse = ' '))
                                                 }))
    
    layerData <- colume_number %>%
      pivot_longer(cols = description, 
                   names_to = 'is_type', 
                   values_to = 'with_entry') %>%
      mutate(table_name = 'data') %>%
      bind_rows(layerData) 
    
    # Convert all columns to character type and return the modified data
    return(bind_rows(studyData, layerData))
  }) 
  
```

```{r}

##This table is incomplete and the text will need to be processed
##One strategy could be to use a fill with groupings
# ColumnNameCorrections <- tribble(~doi, ~column_index, ~column_name_new,
#   "10.1594/PANGAEA.934281", 10, 'Age unc [±] (Age, tephra-chronostratigraphy, calculated, 1 sigma)',
#  "10.1594/PANGAEA.934343",9, 'Age unc [±] (Age, tephra-chronostratigraphy, calculated, 1 sigma)',
#  "10.1594/PANGAEA.941094", 10, 'Age [a AD/CE] alt.',
#  "10.1594/PANGAEA.929068", 5, 'alt.',
#  "10.1594/PANGAEA.929068", 6, 'alt.',
#  "10.1594/PANGAEA.929068", 7, 'alt.',
#  "10.1594/PANGAEA.(929655)|(930133)", 2, 'Cal age [ka BP] (Median Age, 14C calibrated, OxCal 4.2.4)',
#  "10.1594/PANGAEA.(929655)|(930133)", 3, 'Cal age max [ka BP] (Age, 14C calibrated, OxCal 4.2.4)',
#  "10.1594/PANGAEA.(929655)|(930133)", 4, 'Cal age min [ka BP] (Age, 14C calibrated, OxCal 4.2.4)',
#  "10.1594/PANGAEA.(929655)|(930133)", 6, 'Cal age [ka BP] (Median Age, 14C calibrated, Bacon 2.2)',
#  "10.1594/PANGAEA.(929655)|(930133)", 7, 'Cal age max [ka BP] (Age, 14C calibrated, Bacon 2.2)', 
#  "10.1594/PANGAEA.(929655)|(930133)", 8, 'Cal age min [ka BP] (Age, 14C calibrated, Bacon 2.2)',
#  "10.1594/PANGAEA.930030", 2, 'Cal age [ka BP] (Median Age, 14C calibrated, OxCal 4.2.4)',
#  "10.1594/PANGAEA.930030", 3, 'Cal age max [ka BP] (Age, 14C calibrated, OxCal 4.2.4)',
#  "10.1594/PANGAEA.930030", 4, 'Cal age min [ka BP] (Age, 14C calibrated, OxCal 4.2.4)',
#  "10.1594/PANGAEA.930030", 5, 'Cal age [ka BP] (Median Age, 14C calibrated, Bacon 2.2)', 
#  "10.1594/PANGAEA.930030", 6, 'Cal age max [ka BP] (Age, 14C calibrated, Bacon 2.2)', 
#  "10.1594/PANGAEA.930030", 7, 'Cal age min [ka BP] (Age, 14C calibrated, Bacon 2.2)')
# 
# duplicateNames <- long.df %>%
#   filter(str_detect(column_name, pattern = '\\s\\d+$'),
#          is_type == 'description')

flags_ptn <- '((PI)|(METHOD)|(DEVICE)|(COMMENT)|$)'

long_extended.df <- long.df %>%
  #pull everything not associated with a specific row number
  filter(is.na(row_number)) %>%
  mutate(column_name = str_remove(column_name, pattern = '\\s\\d+$'),
         description = if_else(is.na(column_number), NA_character_, with_entry)) %>%
  mutate(new_name = trimws(str_remove(column_name, pattern = '(\\(|\\[).+'))) %>%
  mutate(unit = str_extract(column_name, pattern = '\\[.+\\]')) %>%
  mutate(method = str_extract(column_name, pattern = '\\(.+\\)')) %>%
  mutate(method = str_replace(method, pattern = 'Bacon 2\\.{4}', replacement = 'Bacon 2.2')) %>%
  mutate(method = str_replace(method, pattern = 'OxCal 4\\.{4}', replacement = 'OxCal 4.2.4')) %>%
  mutate(PI = str_remove(str_extract(with_entry, pattern = 'PI.*$'),
                         pattern = '((METHOD)|(DEVICE)|(COMMENT)).*$'),
          METHOD = str_remove(str_extract(with_entry, pattern = 'METHOD.*$'),
                         pattern = '((PI)|(DEVICE)|(COMMENT)).*$'),
          DEVICE = str_remove(str_extract(with_entry, pattern = 'DEVICE.*$'),
                         pattern = '((METHOD)|(PI)|(COMMENT)).*$'),
          COMMENT = str_remove(str_extract(with_entry, pattern = 'COMMENT.*$'),
                         pattern = '((METHOD)|(DEVICE)|(PI)).*$')) %>%
  mutate(method = if_else(is.na(method), METHOD, paste(method, METHOD))) %>%
  select(table_id = table_name, column_id = new_name, column_name, column_number,
         unit, description, method, PI, device=DEVICE, comment=COMMENT) %>%
  unique() %>%
  pivot_longer(cols = all_of(c('unit', 'description', 'method', 'PI', 'device', 'comment')),
               names_to = 'of_type', values_to = 'with_entry', values_drop_na = TRUE)

long_extended.df %>%
  select(table_name, new_name) %>%
  mutate(across(everything(), trimws)) %>%
  unique() %>%
  arrange(table_name, new_name) %>%
  write_csv('temp/autoAnnotations.csv')

annotations <- read_csv('../data/CPEAT_annotations.csv') %>%
  mutate(new_name = trimws(str_remove(column_id, pattern = '(\\(|\\[).+'))) %>%
  select(table_id, new_name, of_variable, of_type, with_entry) %>%
  unique()
#Check the names matching
#setdiff(temp$new_name, long_extended.df$new_name)
```

```{r}

  
  # Read in annotations
  if(verbose) message('Loading annotations.')
  CPEATannotations.df <- readr::read_csv(annotationFilename,
                                    col_type = readr::cols(
                                      .default = readr::col_character())) %>% 
    select(table_id, column_id, of_variable, of_type, with_entry)
  
  if (format == 'long') {
    allData_test <- add_PI_to_study %>%
      dplyr::full_join(allCores.df, by = dplyr::join_by(doi)) %>% 
      dplyr::group_by(doi) %>%
      dplyr::mutate(row_number = row_number()) %>% 
      dplyr::ungroup() %>%
      tidyr::pivot_longer(cols = -row_number, names_to = 'column_id', values_to = 'with_entry', values_drop_na = TRUE) %>% 
      full_join(CPEATannotations.df, 
                by = join_by(column_id),
                suffix = c('.data', ''),
                relationship = "many-to-many") %>% 
      mutate(
        with_entry = dplyr::if_else((with_entry == "--") | is.na(with_entry),
                                    with_entry.data, with_entry)) %>%
      select(-with_entry.data) %>% 
      select(table_id, column_id, of_variable, of_type, with_entry, row_number)
    
```

```{r}

#TODO Remove PI information from the description

# loading in the long format with three distinct tables; stuyd, core, parameters from the old function
oldCPEAT.ls <- readCPEAT(dataDir = dataDir, # used the readCPEAT_old function since it does not have any annotations loaded in.
                         format = 'long')

allCores.df <- oldCPEAT.ls$core  # reading in the core table data
allStudy.df <- oldCPEAT.ls$study # study table data
allParameters.df <- oldCPEAT.ls$parameters # the parameters table. 

# Save parameters to CSV file; to hard code this table such that it can be cross linked to study and core data table. 
write_csv(allParameters.df, file = file.path('temp/', 'Param_annotations.csv'))
  
# Load the CSV file
annotationFile <- 'temp/Param_annotations.csv'
Param_annotations <- read.csv(annotationFile, stringsAsFactors = FALSE)

# extracting just the PI (principle investogator info) here to append it to the study table
Param_extracted <- Param_annotations %>% 
  mutate(PI_info = if_else(
    str_detect(description, "PI[^!]*"),
    str_extract(description, "PI[^!]*"),
    str_extract(description, "PI.*"))) %>% 
  select(doi, PI_info) %>% 
  unique()

# out of the above extracted parameters table with just doi and PI_info; adding two additional columns with method and comment info, if any!
selectParam_extracted <- Param_extracted %>% 
  mutate(METHOD = str_extract(PI_info, "METHOD/DEVICE:.*?(?=COMMENT|$)"),
         COMMENT = str_extract(PI_info, "COMMENT:.*")) %>%
  mutate(METHOD = str_replace(METHOD, "METHOD/DEVICE: ", ""),
         COMMENT = str_replace(COMMENT, "COMMENT: ", ""),
         PI_info = str_remove(PI_info, "METHOD/DEVICE:.*"),
         PI_info = str_remove(PI_info, "COMMENT:.*")) %>%
  mutate(PI_info = str_trim(PI_info, side = "both")) %>% 
  select(doi, PI_info) %>% 
  unique()

# adding this to the original study table; the PI_info has the email address (contact information) of the PI 
add_PI_to_study <- allStudy.df %>% 
  full_join(selectParam_extracted, by = join_by(doi)) %>% 
  unique()

# leveraging the entire parameters table for data annotations by breaking the description column into multiple column info (as metadata)
Parms.df <- Param_annotations %>%
  mutate(PI_info = if_else(
    str_detect(description, "PI[^!]*"),
    str_extract(description, "PI[^!]*"),
    str_extract(description, "PI.*"))) %>% 
  mutate(METHOD = str_extract(PI_info, "METHOD/DEVICE:.*?(?=COMMENT|$)"),
         COMMENT = str_extract(PI_info, "COMMENT:.*")) %>%
  mutate(METHOD = str_replace(METHOD, "METHOD/DEVICE: ", ""),
         COMMENT = str_replace(COMMENT, "COMMENT: ", ""),
         PI_info = str_remove(PI_info, "METHOD/DEVICE:.*"),
         PI_info = str_remove(PI_info, "COMMENT:.*")) %>%
  mutate(PI_info = str_trim(PI_info, side = "both")) %>% 
  mutate(Meta_info = ifelse(
    str_detect(description, "GEOCODE"),
    str_extract(description, ".*(?=GEOCODE)"),
    str_extract(description, ".*(?=PI)"))) %>% 
  select(doi, header, description = Meta_info, METHOD, COMMENT) %>% 
  unique()
```

# Annotations hard coded

```{r}
##Draft annotations for later manual curation
ConstructAnnotations <- allCores.df %>%
  mutate(across(.cols=everything(), as.character)) %>%
  mutate(core_id = doi) %>% #1:n()) %>%
  pivot_longer(cols=-c(core_id), values_drop_na = TRUE, names_to = 'column_name')  %>%
  reframe(example_entry = paste(unique(value)[1:5], collapse = '; '),
          obs_count = sum(!is.na(value)),
          .by = c(core_id, column_name)) %>%
  full_join(Parms.df,
            by = c('core_id' = 'doi', 'column_name' = 'header')) %>%
  select(core_id, column_name, example_entry, obs_count, description) %>%
  mutate(of_variable = case_when( str_detect(column_name, 'doi') ~ 'doi',
                                  str_detect(column_name, '[Dd]epth sed') ~ 'layer_mid',
                                  str_detect(column_name, '[Dd]epth bot') ~ 'layer_bottom',
                                  str_detect(column_name, '[Dd]epth top') ~ 'layer_top',
                                  str_detect(column_name, 'Peat') ~ 'peat_description',
                                  str_detect(column_name, '[Aa]ge') ~ 'age',
                                  str_detect(column_name, 'Samp thick') ~ 'layer_thickness',
                                  str_detect(column_name, 'DBD') ~ 'bulk_density',
                                  str_detect(column_name, '^OM') ~ 'organic_matter',
                                  str_detect(column_name, '^LOI') ~ 'loss_on_ignition',
                                  str_detect(column_name, 'Corg') ~ 'organic_carbon',
                                  str_detect(column_name, '[Vv]ol ') ~ 'volume',
                                  str_detect(column_name, '^C ') ~ 'organic_carbon',
                                  str_detect(column_name, 'TOC') ~ 'organic_carbon',
                                  str_detect(column_name, 'TIC') ~ 'inorganic_carbon',
                                  str_detect(column_name, '^TC') ~ 'total_carbon',
                                  str_detect(column_name, '^TN') ~ 'total_nitrogen',
                                  str_detect(column_name, 'Dated material') ~ 'age',
                                  str_detect(column_name, '[Cc]omm') ~ 'age',
                                  str_detect(column_name, 'label') ~ 'lab_label',
                                  str_detect(column_name, 'Activity') ~ 'modern_carbon_activity',
                                  str_detect(column_name, 'F14C') ~ 'modern_carbon_activity',
                                  str_detect(column_name, 'SR') ~ 'sedimentation_rate',
                                  str_detect(column_name, 'Water') ~ 'water_content',
                                  str_detect(column_name, 'Cum mass') ~ 'total_core_mass',
                                  str_detect(column_name, 'PCAR') ~ 'peat_accumulation_rate',
                                  TRUE ~ NA),
         unit = case_when(
           str_detect(column_name, '\\[m\\]') ~ 'm',
           str_detect(column_name, '\\[ka.*\\]') ~ 'ka BP',
           str_detect(column_name, '\\[g/cm\\*\\*3\\]') ~ 'g cm-3',
           str_detect(column_name, '\\[cm\\]') ~ 'cm',
           str_detect(column_name, '\\[%\\]') ~ 'mass percent',
           str_detect(column_name, '\\[pMC\\]') ~ 'modern carbon percent',
           str_detect(column_name, 'F14C') ~ 'modern carbon fraction',
           str_detect(column_name, '\\[a AD/CE\\]') ~ 'a CE',
           str_detect(column_name, '\\[cm/a\\]') ~ 'cm yr-1',
           str_detect(column_name, '\\[ml\\]') ~ 'mL',
           str_detect(column_name, '\\[cm\\*\\*3\\]') ~ 'cm3',
           str_detect(column_name, '\\[g/cm\\*\\*2\\]') ~ 'g cm-2',
           str_detect(column_name, '\\[g/m\\*\\*2\\/a]') ~ 'g m-2 yr-1',
           str_detect(column_name, '[a] (years ago)') ~ 'yr before measure',
           TRUE ~ NA),
         type = case_when( str_detect(column_name, 'max') ~ 'maximum',
                           str_detect(column_name, 'min') ~ 'maximum',
                           str_detect(column_name, '±') ~ '1 sigma',
                           str_detect(column_name, 'Peat') ~ 'note', #no control vocabulary
                           !is.na(unit) ~ 'value',
                           str_detect(column_name, 'Dat.* material') ~ 'method',
                           str_detect(column_name, '[Cc]omm') ~ 'method',
                           str_detect(column_name, 'label') ~ 'id',
                           str_detect(column_name, 'doi') ~ 'id',
                           TRUE ~ NA)) %>%
  mutate(calibration_status = case_when(of_variable != 'age' | type != 'value' ~ '',
                                        str_detect(column_name, 'Age dated [ka]') ~ 'uncalibrated',
                                        str_detect(column_name, '[Uu]ncalibrated') ~ 'uncalibrated',
                                        #str_detect(description, '[Uu]ncalibrated') ~ 'uncalibrated',
                                        str_detect(column_name, 'calibrated') ~ 'calibrated',
                                        #str_detect(description, 'calibrated') ~ 'calibrated',
                                        TRUE ~ ''),
         age_model = case_when(of_variable != 'age' | type != 'value' ~ '',
                               str_detect(column_name, 'OxCal') ~ 'OxCal_4.2.4',
                               #str_detect(description, 'OxCal') ~ 'OxCal_4.2.4',
                               str_detect(column_name, 'Bacon') ~ 'Bacon_2.2',
                               #str_detect(description, 'Bacon') ~ 'Bacon_2.2',
                               TRUE ~ ''),
         isotope = case_when(of_variable != 'age' | type != 'value' ~ '',
                             str_detect(column_name, '14C') ~ '14C',
                             #str_detect(description, '14C') ~ '14C',
                             str_detect(column_name, '210Pb') ~ '210Pb',
                             #str_detect(description, '210Pb') ~ '210Pb',
                             str_detect(column_name, 'ephra-chronostratigraphy') ~ 'tephra-chronostratigraphy',
                             #str_detect(description, 'ephra-chronostratigraphy') ~ 'tephra-chronostratigraphy',
                             TRUE ~ '')) %>%
  mutate(across(.cols = -column_name, str_trim)) %>%
  mutate(method = paste(isotope, age_model, calibration_status)) %>%
  mutate(table_name = 'core') %>%
  select(core_id, column_name, of_variable, unit, type, method, description) %>%
  mutate(across(.cols = -column_name, str_trim)) %>%
  unique() %>% 
  mutate(table_name = 'core')

coreAnnotationSub1 <- ConstructAnnotations %>% 
  select(core_id, column_name, of_variable, of_type = type) %>%
  unique() %>%
  mutate(with_entry = '--') %>% 
  mutate(table_name = 'core')

coreAnnotationSub2 <- ConstructAnnotations %>% 
  select(-type) %>%
  unique() %>%
  pivot_longer(cols = c(unit, method, description), names_to = 'of_type', values_to = 'with_entry') %>%
  mutate(with_entry = str_trim(with_entry)) %>%
  filter(str_detect(pattern = '\\w', with_entry)) %>% 
  select(-core_id) %>% 
  unique() %>% 
  mutate(table_name = 'core')

studyAnnotation <- tribble(~column_name, ~description, ~of_variable, ~unit,
                           "core_name", "Core name", "core_name", NA_character_,
                           "parent_doi", "data package DOI", "data_doi",  NA_character_,
                           "doi",  "data package DOI", "data_doi",  NA_character_, #same as doi
                           "citation", "Citation", 'citation',  NA_character_,
                           "url", "download url", 'download_url',  NA_character_,
                           "path", "download path", 'data_local_filepath',  NA_character_,
                           "citation.1", "Citation", 'citation', NA_character_, #same as citation
                           "related_to", "Related citations", 'related_citation', NA_character_,
                           "projects", "Related project", 'project', NA_character_,
                           "coverage", "Bounded coverage", 'bounded_coverage', NA_character_,
                           "license", "Data license", 'data_license', NA_character_,
                           "size", "Observation size", 'observation_size', 'data point count',
                           "LATITUDE", "Latitude", 'latitude', 'decimal degree',
                           "LONGITUDE", "Longitude", 'longitude', 'decimal degree',
                           "LOCATION", "Adminstrative region", 'region', NA_character_,
                           "METHOD.DEVICE", "Sampling devise", 'sample_devise', NA_character_,
                           "COMMENT", "Data package comment", 'core_comment', NA_character_,
                           "further_details", "Citations", 'futher_citations', NA_character_,
                           "ELEVATION", "elevation", 'elevation', 'm',
                           "Recovery", "core length", 'core_length', 'cm',
                           "Penetration", "core length", 'core_length', 'cm',
                           "ELEVATION.START", "Start of elevation transect", 'elevation_start', 'm',
                           "ELEVATION.END", "End of elevation transect", 'elevation_end', 'm',
                           "abstract", "Abstract", 'abstract', NA_character_,
                           "keywords", "Keywords", 'keywords', NA_character_,
                           "status", "Curation level", 'cutation_level', NA_character_,
                           "comment", "Dataset Comment", 'core_comment', NA_character_,
                           "PI_info", "PI details including email address", "Principal_Investigator_information", NA_character_) %>%
  mutate(table_name = 'study')

studyAnnotationSub1 <- studyAnnotation %>%
  pivot_longer(cols = c(description, unit), 
               names_to = 'of_type',
               values_to = 'with_entry',
               values_drop_na = TRUE)

studyAnnotationSub2 <- studyAnnotation %>% 
  select(column_name, of_variable) %>%
  mutate(of_type = if_else(of_variable == 'core_comment', 'note', 'value'),
         with_entry = '--') %>% 
  mutate(table_name = 'study')


annotation.df <- bind_rows(coreAnnotationSub1, coreAnnotationSub2,
                           studyAnnotationSub1, studyAnnotationSub2) %>%
  rename(c(column_id = column_name, table_id = table_name)) %>% 
  select(-core_id) %>% 
  arrange(column_id, of_variable, of_type) %>% 
  unique()

# Save annotations to CSV file; so that it can be cross linked to study and core data table in the readCPEAT function. 
write_csv(annotation.df, file = file.path('temp/', 'CPEAT_annotations.csv'))

```

# testing if the function works or not! 

Used the readCPEAT.R function here; long format produces two tables with annotations and the pivot long table with table_id, column_id, of_variable,
of_type and with_entry. 

```{r}
dataDir <- './temp'
Annotations <- './temp/CPEAT_annotations.csv'
testrun <- readCPEAT(dataDir, 
                  annotationFilename = Annotations, 
                  verbose = FALSE, #when first running, switch this to true 
                  format = 'long') # gives 6,569,631 entries, 6 total columns (includes row_number)
```

# TODO; not to be executed for now!

```{r, eval=FALSE}
# testing for unique METHOD columns to extract the metadata information
temp <- Parms.df %>% 
  select(-c(doi, COMMENT)) %>% 
  filter(!is.na(METHOD)) %>% 
  unique()

temp2 <- Parms.df$METHOD %>% 
  unique()
```


```{r, eval=FALSE}         
##Draft annotations for later manual curation [THIS IS THE ORGIGINAL ANNOTATIONS CONSTRUCTION] 
constructedCoreAnnotations <- allCores.df %>%
  mutate(across(.cols=everything(), as.character)) %>%
  mutate(core_id = doi) %>% #1:n()) %>%
  pivot_longer(cols=-c(core_id), values_drop_na = TRUE, names_to = 'column_name')  %>%
  reframe(example_entry = paste(unique(value)[1:5], collapse = '; '),
          obs_count = sum(!is.na(value)),
          .by = c(core_id, column_name)) %>%
  full_join(allParameters.df,
            by = c('core_id' = 'doi', 'column_name' = 'header')) %>%
  select(core_id, column_name, description, example_entry, obs_count) %>%
  mutate(of_variable = case_when( str_detect(column_name, 'doi') ~ 'doi',
                                  str_detect(column_name, '[Dd]epth sed') ~ 'layer_mid',
                                  str_detect(column_name, '[Dd]epth bot') ~ 'layer_bottom',
                                  str_detect(column_name, '[Dd]epth top') ~ 'layer_top',
                                  str_detect(column_name, 'Peat') ~ 'peat',
                                  str_detect(column_name, '[Aa]ge') ~ 'age',
                                  str_detect(column_name, 'Samp thick') ~ 'layer_thickness',
                                  str_detect(column_name, 'DBD') ~ 'bulk_density',
                                  str_detect(column_name, '^OM') ~ 'organic_matter',
                                  str_detect(column_name, '^LOI') ~ 'loss_on_ignition',
                                  str_detect(column_name, 'Corg') ~ 'organic_carbon',
                                  str_detect(column_name, '[Vv]ol ') ~ 'volume',
                                  str_detect(column_name, '^C ') ~ 'organic_carbon',
                                  str_detect(column_name, 'TOC') ~ 'organic_carbon',
                                  str_detect(column_name, 'TIC') ~ 'inorganic_carbon',
                                  str_detect(column_name, '^TC') ~ 'total_carbon',
                                  str_detect(column_name, '^TN') ~ 'total_nitrogen',
                                  str_detect(column_name, 'Dated material') ~ 'age',
                                  str_detect(column_name, '[Cc]omm') ~ 'age',
                                  str_detect(column_name, 'label') ~ 'lab_label',
                                  str_detect(column_name, 'Activity') ~ 'modern_carbon_activity',
                                  str_detect(column_name, 'F14C') ~ 'modern_carbon_activity',
                                  str_detect(column_name, 'SR') ~ 'sedimentation_rate',
                                  str_detect(column_name, 'Water') ~ 'water_content',
                                  str_detect(column_name, 'Cum mass') ~ 'total_core_mass',
                                  str_detect(column_name, 'PCAR') ~ 'peat_accumulation_rate',
                                  TRUE ~ NA),
         unit = case_when(
           str_detect(column_name, '\\[m\\]') ~ 'm',
           str_detect(column_name, '\\[ka.*\\]') ~ 'ka BP',
           str_detect(column_name, '\\[g/cm\\*\\*3\\]') ~ 'g cm-3',
           str_detect(column_name, '\\[cm\\]') ~ 'cm',
           str_detect(column_name, '\\[%\\]') ~ 'mass percent',
           str_detect(column_name, '\\[pMC\\]') ~ 'modern carbon percent',
           str_detect(column_name, 'F14C') ~ 'modern carbon fraction',
           str_detect(column_name, '\\[a AD/CE\\]') ~ 'a CE',
           str_detect(column_name, '\\[cm/a\\]') ~ 'cm yr-1',
           str_detect(column_name, '\\[ml\\]') ~ 'mL',
           str_detect(column_name, '\\[cm\\*\\*3\\]') ~ 'cm3',
           str_detect(column_name, '\\[g/cm\\*\\*2\\]') ~ 'g cm-2',
           str_detect(column_name, '\\[g/m\\*\\*2\\/a]') ~ 'g m-2 yr-1',
           str_detect(column_name, '[a] (years ago)') ~ 'yr before measure',
           TRUE ~ NA),
         type = case_when( str_detect(column_name, 'max') ~ 'maximum',
                           str_detect(column_name, 'min') ~ 'maximum',
                           str_detect(column_name, '±') ~ '1 sigma',
                           str_detect(column_name, 'Peat') ~ 'note', #no control vocabulary
                           !is.na(unit) ~ 'value',
                           str_detect(column_name, 'Dat.* material') ~ 'method',
                           str_detect(column_name, '[Cc]omm') ~ 'method',
                           str_detect(column_name, 'label') ~ 'id',
                           str_detect(column_name, 'doi') ~ 'id',
                           TRUE ~ NA)) %>%
  mutate(calibration_status = case_when(of_variable != 'age' | type != 'value' ~ '',
                                        str_detect(column_name, 'Age dated [ka]') ~ 'uncalibrated',
                                        str_detect(column_name, '[Uu]ncalibrated') ~ 'uncalibrated',
                                        str_detect(description, '[Uu]ncalibrated') ~ 'uncalibrated',
                                        str_detect(column_name, 'calibrated') ~ 'calibrated',
                                        str_detect(description, 'calibrated') ~ 'calibrated',
                                        TRUE ~ ''),
         age_model = case_when(of_variable != 'age' | type != 'value' ~ '',
                               str_detect(column_name, 'OxCal') ~ 'OxCal_4.2.4',
                               str_detect(description, 'OxCal') ~ 'OxCal_4.2.4',
                               str_detect(column_name, 'Bacon') ~ 'Bacon_2.2',
                               str_detect(description, 'Bacon') ~ 'Bacon_2.2',
                               TRUE ~ ''),
         isotope = case_when(of_variable != 'age' | type != 'value' ~ '',
                             str_detect(column_name, '14C') ~ '14C',
                             str_detect(description, '14C') ~ '14C',
                             str_detect(column_name, '210Pb') ~ '210Pb',
                             str_detect(description, '210Pb') ~ '210Pb',
                             str_detect(column_name, 'ephra-chronostratigraphy') ~ 'tephra-chronostratigraphy',
                             str_detect(description, 'ephra-chronostratigraphy') ~ 'tephra-chronostratigraphy',
                             TRUE ~ '')) %>%
  mutate(across(.cols = -column_name, str_trim)) %>%
  mutate(method = paste(isotope, age_model, calibration_status)) %>%
  mutate(table_name = 'core') %>%
  select(core_id, column_name, of_variable, unit, type, method, description) %>%
  mutate(across(.cols = -column_name, str_trim)) %>%
  unique()

coreAnnotationSub1 <- constructedCoreAnnotations %>% 
  select(core_id, column_name, of_variable, of_type = type) %>%
  unique() %>%
  mutate(with_entry = '--')

coreAnnotationSub2 <- constructedCoreAnnotations %>% 
  select(-type) %>%
  unique() %>%
  pivot_longer(cols = c(unit, method, description), names_to = 'of_type', values_to = 'with_entry') %>%
  mutate(with_entry = str_trim(with_entry)) %>%
  filter(str_detect(pattern = '\\w', with_entry))

studyAnnotation <- tribble(~column_name, ~description, ~of_variable, ~unit,
                           "core_name", "Core name", "core_name", NA_character_,
                           "parent_doi", "data package DOI", "data_doi",  NA_character_,
                           "doi",  "data package DOI", "data_doi",  NA_character_, #same as doi
                           "citation", "Citation", 'citation',  NA_character_,
                           "url", "download url", 'download_url',  NA_character_,
                           "path", "download path", 'data_local_filepath',  NA_character_,
                           "citation.1", "Citation", 'citation', NA_character_, #same as citation
                           "related_to", "Related citations", 'related_citation', NA_character_,
                           "projects", "Related project", 'project', NA_character_,
                           "coverage", "Bounded coverage", 'bounded_coverage', NA_character_,
                           "license", "Data license", 'data_license', NA_character_,
                           "size", "Observation size", 'observation_size', 'data point count',
                           "LATITUDE", "Latitude", 'latitude', 'decimal degree',
                           "LONGITUDE", "Longitude", 'longitude', 'decimal degree',
                           "LOCATION", "Adminstrative region", 'region', NA_character_,
                           "METHOD.DEVICE", "Sampling devise", 'sample_devise', NA_character_,
                           "COMMENT", "Data package comment", 'core_comment', NA_character_,
                           "further_details", "Citations", 'futher_citations', NA_character_,
                           "ELEVATION", "elevation", 'elevation', 'm',
                           "Recovery", "core length", 'core_length', 'cm',
                           "Penetration", "core length", 'core_length', 'cm',
                           "ELEVATION.START", "Start of elevation transect", 'elevation_start', 'm',
                           "ELEVATION.END", "End of elevation transect", 'elevation_end', 'm',
                           "abstract", "Abstract", 'abstract', NA_character_,
                           "keywords", "Keywords", 'keywords', NA_character_,
                           "status", "Curation level", 'cutation_level', NA_character_,
                           "comment", "Dataset Comment", 'core_comment', NA_character_) %>%
  mutate(table_name = 'study')

studyAnnotationSub1 <- studyAnnotation %>%
  pivot_longer(cols = c(description, unit), 
               names_to = 'of_type',
               values_to = 'with_entry',
               values_drop_na = TRUE)

studyAnnotationSub2 <- studyAnnotation %>% 
  select(column_name, of_variable) %>%
  mutate(of_type = if_else(of_variable == 'core_comment', 'note', 'value'),
         with_entry = '--') 


annotation.df <- bind_rows(coreAnnotationSub1, coreAnnotationSub2,
                           studyAnnotationSub1, studyAnnotationSub2) %>%
  arrange(table_name, core_id, of_variable, of_type)
  
  
```



